<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÌîΩÏÖÄÏïÑÌä∏ ÏóêÎîîÌÑ∞</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .tools {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            align-items: center;
        }
        
        .tool-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .color-picker {
            width: 50px;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .canvas-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        #pixelCanvas {
            border: 2px solid #333;
            cursor: crosshair;
            background-color: white;
            image-rendering: pixelated;
        }
        
        .controls {
            text-align: center;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }
        
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        button.active {
            background-color: #28a745;
        }
        
        select, input {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        
        .preset-colors {
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
            max-width: 800px;
        }
        
        .preset-color {
            width: 25px;
            height: 25px;
            border: 2px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }
        
        .preset-color:hover {
            border-color: #333;
            transform: scale(1.1);
        }
        
        /* NFT Í¥ÄÎ†® Ïä§ÌÉÄÏùº */
        .nft-section {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-left: 20px;
            padding-left: 20px;
            border-left: 2px solid #ddd;
        }
        
        #walletStatus {
            font-size: 12px;
            color: #666;
            background-color: #f8f9fa;
            padding: 5px 10px;
            border-radius: 15px;
        }
        
        #walletStatus.connected {
            color: #28a745;
            background-color: #d4edda;
        }
        
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: white;
            margin: 10% auto;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            position: relative;
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            right: 15px;
            top: 10px;
        }
        
        .close:hover {
            color: #000;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        .form-group input,
        .form-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            box-sizing: border-box;
        }
        
        .form-group textarea {
            height: 80px;
            resize: vertical;
        }
        
        .form-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
        
        #confirmMint {
            background-color: #28a745;
        }
        
        #confirmMint:hover {
            background-color: #218838;
        }
        
        #cancelMint {
            background-color: #6c757d;
        }
        
        #cancelMint:hover {
            background-color: #5a6268;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé® ÌîΩÏÖÄÏïÑÌä∏ ÏóêÎîîÌÑ∞</h1>
        </div>
        
        <div class="tools">
            <div class="tool-group">
                <label>Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞:</label>
                <select id="canvasSize">
                    <option value="8">8x8</option>
                    <option value="16" selected>16x16</option>
                    <option value="32">32x32</option>
                    <option value="64">64x64</option>
                </select>
            </div>
            
            <div class="tool-group">
                <label>ÌîΩÏÖÄ ÌÅ¨Í∏∞:</label>
                <select id="pixelSize">
                    <option value="16">16px</option>
                    <option value="20">20px</option>
                    <option value="24">24px</option>
                    <option value="32" selected>32px</option>
                    <option value="40">40px</option>
                </select>
            </div>
            
            <div class="tool-group">
                <label>ÏÉâÏÉÅ:</label>
                <input type="color" id="colorPicker" class="color-picker" value="#000000">
            </div>
            
            <div class="tool-group">
                <button id="penTool" class="active">Ìéú</button>
                <button id="eraserTool">ÏßÄÏö∞Í∞ú</button>
                <button id="bucketTool">Ï±ÑÏö∞Í∏∞</button>
            </div>
        </div>
        
        <div class="tools">
            <div class="tool-group">
                <label>ÌîÑÎ¶¨ÏÖã ÏÉâÏÉÅ:</label>
                <div class="preset-colors">
                    <!-- Í∏∞Î≥∏ ÏÉâÏÉÅ -->
                    <div class="preset-color" style="background-color: #000000" data-color="#000000" title="Í≤ÄÏ†ï"></div>
                    <div class="preset-color" style="background-color: #ffffff" data-color="#ffffff" title="Ìù∞ÏÉâ"></div>
                    <div class="preset-color" style="background-color: #808080" data-color="#808080" title="ÌöåÏÉâ"></div>
                    <div class="preset-color" style="background-color: #c0c0c0" data-color="#c0c0c0" title="Ïó∞Ìïú ÌöåÏÉâ"></div>
                    
                    <!-- Îπ®Í∞ï Í≥ÑÏó¥ -->
                    <div class="preset-color" style="background-color: #ff0000" data-color="#ff0000" title="Îπ®Í∞ï"></div>
                    <div class="preset-color" style="background-color: #ff6b6b" data-color="#ff6b6b" title="ÏΩîÎûÑ"></div>
                    <div class="preset-color" style="background-color: #ff9999" data-color="#ff9999" title="Ïó∞Ìïú Îπ®Í∞ï"></div>
                    <div class="preset-color" style="background-color: #8b0000" data-color="#8b0000" title="Îã§ÌÅ¨ Î†àÎìú"></div>
                    
                    <!-- Ï£ºÌô© Í≥ÑÏó¥ -->
                    <div class="preset-color" style="background-color: #ffa500" data-color="#ffa500" title="Ïò§Î†åÏßÄ"></div>
                    <div class="preset-color" style="background-color: #ffb347" data-color="#ffb347" title="ÌîºÏπò"></div>
                    <div class="preset-color" style="background-color: #ff8c00" data-color="#ff8c00" title="Îã§ÌÅ¨ Ïò§Î†åÏßÄ"></div>
                    
                    <!-- ÎÖ∏Îûë Í≥ÑÏó¥ -->
                    <div class="preset-color" style="background-color: #ffff00" data-color="#ffff00" title="ÎÖ∏Îûë"></div>
                    <div class="preset-color" style="background-color: #ffd700" data-color="#ffd700" title="Í≥®Îìú"></div>
                    <div class="preset-color" style="background-color: #fff8dc" data-color="#fff8dc" title="ÌÅ¨Î¶º"></div>
                    
                    <!-- Ï¥àÎ°ù Í≥ÑÏó¥ -->
                    <div class="preset-color" style="background-color: #00ff00" data-color="#00ff00" title="Ï¥àÎ°ù"></div>
                    <div class="preset-color" style="background-color: #4caf50" data-color="#4caf50" title="Í∑∏Î¶∞"></div>
                    <div class="preset-color" style="background-color: #90ee90" data-color="#90ee90" title="Ïó∞Ìïú Ï¥àÎ°ù"></div>
                    <div class="preset-color" style="background-color: #228b22" data-color="#228b22" title="Ìè¨Î†àÏä§Ìä∏ Í∑∏Î¶∞"></div>
                    <div class="preset-color" style="background-color: #32cd32" data-color="#32cd32" title="ÎùºÏûÑ Í∑∏Î¶∞"></div>
                    
                    <!-- ÌååÎûë Í≥ÑÏó¥ -->
                    <div class="preset-color" style="background-color: #0000ff" data-color="#0000ff" title="ÌååÎûë"></div>
                    <div class="preset-color" style="background-color: #4169e1" data-color="#4169e1" title="Î°úÏñÑ Î∏îÎ£®"></div>
                    <div class="preset-color" style="background-color: #87ceeb" data-color="#87ceeb" title="Ïä§Ïπ¥Ïù¥ Î∏îÎ£®"></div>
                    <div class="preset-color" style="background-color: #000080" data-color="#000080" title="ÎÑ§Ïù¥ÎπÑ"></div>
                    <div class="preset-color" style="background-color: #1e90ff" data-color="#1e90ff" title="Îî• Ïä§Ïπ¥Ïù¥ Î∏îÎ£®"></div>
                    
                    <!-- Î≥¥Îùº Í≥ÑÏó¥ -->
                    <div class="preset-color" style="background-color: #9932cc" data-color="#9932cc" title="ÌçºÌîå"></div>
                    <div class="preset-color" style="background-color: #dda0dd" data-color="#dda0dd" title="ÌîåÎüº"></div>
                    <div class="preset-color" style="background-color: #8a2be2" data-color="#8a2be2" title="Î∞îÏù¥Ïò¨Î†õ"></div>
                    <div class="preset-color" style="background-color: #e6e6fa" data-color="#e6e6fa" title="ÎùºÎ≤§Îçî"></div>
                    
                    <!-- Î∂ÑÌôç Í≥ÑÏó¥ -->
                    <div class="preset-color" style="background-color: #ff69b4" data-color="#ff69b4" title="Ìï´ ÌïëÌÅ¨"></div>
                    <div class="preset-color" style="background-color: #ffc0cb" data-color="#ffc0cb" title="ÌïëÌÅ¨"></div>
                    <div class="preset-color" style="background-color: #ffb6c1" data-color="#ffb6c1" title="ÎùºÏù¥Ìä∏ ÌïëÌÅ¨"></div>
                    
                    <!-- Í∞àÏÉâ Í≥ÑÏó¥ -->
                    <div class="preset-color" style="background-color: #8b4513" data-color="#8b4513" title="Î∏åÎùºÏö¥"></div>
                    <div class="preset-color" style="background-color: #d2691e" data-color="#d2691e" title="Ï¥àÏΩúÎ¶ø"></div>
                    <div class="preset-color" style="background-color: #daa520" data-color="#daa520" title="Í≥®Îì†Î°úÎìú"></div>
                    
                    <!-- ÌäπÎ≥ÑÌïú ÏÉâÏÉÅÎì§ -->
                    <div class="preset-color" style="background-color: #00ffff" data-color="#00ffff" title="ÏãúÏïà"></div>
                    <div class="preset-color" style="background-color: #ff00ff" data-color="#ff00ff" title="ÎßàÏ††ÌÉÄ"></div>
                    <div class="preset-color" style="background-color: #40e0d0" data-color="#40e0d0" title="ÌÑ∞ÏΩ∞Ïù¥Ï¶à"></div>
                    <div class="preset-color" style="background-color: #98fb98" data-color="#98fb98" title="ÌéòÏùº Í∑∏Î¶∞"></div>
                    <div class="preset-color" style="background-color: #f0e68c" data-color="#f0e68c" title="Ïπ¥ÌÇ§"></div>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="pixelCanvas"></canvas>
        </div>
        
        <div class="controls">
            <button id="clearCanvas">Ï†ÑÏ≤¥ ÏßÄÏö∞Í∏∞</button>
            <button id="downloadImage">PNG Îã§Ïö¥Î°úÎìú</button>
            <button id="gridToggle">Í≤©Ïûê ÌÜ†Í∏Ä</button>
            
            <!-- NFT ÎØºÌåÖ ÏÑπÏÖò -->
            <div class="nft-section">
                <button id="connectWallet">ÏßÄÍ∞ë Ïó∞Í≤∞</button>
                <button id="mintNFT" disabled>NFT ÎØºÌåÖ</button>
                <span id="walletStatus">ÏßÄÍ∞ë Ïó∞Í≤∞ ÏïàÎê®</span>
            </div>
        </div>
        
        <!-- NFT Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Î™®Îã¨ -->
        <div id="nftModal" class="modal" style="display: none;">
            <div class="modal-content">
                <span class="close">&times;</span>
                <h2>NFT Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏûÖÎ†•</h2>
                <form id="nftForm">
                    <div class="form-group">
                        <label for="nftName">ÏûëÌíà Ï†úÎ™©:</label>
                        <input type="text" id="nftName" required placeholder="Ïòà: My Pixel Art">
                    </div>
                    <div class="form-group">
                        <label for="nftDescription">ÏÑ§Î™Ö:</label>
                        <textarea id="nftDescription" placeholder="ÏûëÌíàÏóê ÎåÄÌïú ÏÑ§Î™ÖÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="nftAttributes">ÏÜçÏÑ± (ÏÑ†ÌÉùÏÇ¨Ìï≠):</label>
                        <input type="text" id="nftAttributes" placeholder="Ïòà: ÏÉâÏÉÅ:Îπ®Í∞ï, ÌÅ¨Í∏∞:16x16">
                    </div>
                    <div class="form-buttons">
                        <button type="button" id="cancelMint">Ï∑®ÏÜå</button>
                        <button type="submit" id="confirmMint">ÎØºÌåÖÌïòÍ∏∞</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.10.0/web3.min.js"></script>
    <script>
        class PixelArtEditor {
            constructor() {
                this.canvas = document.getElementById('pixelCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gridSize = 16;
                this.pixelSize = 32;
                this.currentColor = '#000000';
                this.currentTool = 'pen';
                this.isDrawing = false;
                this.showGrid = true;
                this.pixels = {};
                
                // Web3 Í¥ÄÎ†®
                this.web3 = null;
                this.account = null;
                this.contract = null;
                
                // Ïä§ÎßàÌä∏ Ïª®Ìä∏ÎûôÌä∏ Ï†ïÎ≥¥ (Mumbai ÌÖåÏä§Ìä∏ÎÑ∑)
                this.contractAddress = "0x1234567890123456789012345678901234567890"; // Î∞∞Ìè¨ ÌõÑ ÏóÖÎç∞Ïù¥Ìä∏ ÌïÑÏöî
                this.contractABI = [
                    {
                        "inputs": [
                            {"internalType": "address", "name": "to", "type": "address"},
                            {"internalType": "string", "name": "tokenURI", "type": "string"}
                        ],
                        "name": "mint",
                        "outputs": [],
                        "stateMutability": "nonpayable",
                        "type": "function"
                    }
                ];
                
                this.initCanvas();
                this.bindEvents();
                this.initWeb3();
            }
            
            initCanvas() {
                const canvasPixelSize = this.gridSize * this.pixelSize;
                this.canvas.width = canvasPixelSize;
                this.canvas.height = canvasPixelSize;
                this.ctx.imageSmoothingEnabled = false;
                this.clearCanvas();
                this.drawGrid();
            }
            
            clearCanvas() {
                // Ï∫îÎ≤ÑÏä§ ÏôÑÏ†ÑÌûà ÏßÄÏö∞Í∏∞
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Ìù∞ÏÉâ Î∞∞Í≤ΩÏúºÎ°ú Ï±ÑÏö∞Í∏∞
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // ÌîΩÏÖÄ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
                this.pixels = {};
                
                // Í≤©Ïûê Îã§Ïãú Í∑∏Î¶¨Í∏∞
                this.drawGrid();
                
                console.log('Ï∫îÎ≤ÑÏä§Í∞Ä ÏßÄÏõåÏ°åÏäµÎãàÎã§!'); // ÎîîÎ≤ÑÍπÖÏö©
            }
            
            drawGrid() {
                if (!this.showGrid) return;
                
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                
                for (let x = 0; x <= this.canvas.width; x += this.pixelSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y <= this.canvas.height; y += this.pixelSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }
            
            getPixelPosition(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = Math.floor((e.clientX - rect.left) / this.pixelSize);
                const y = Math.floor((e.clientY - rect.top) / this.pixelSize);
                return { x, y };
            }
            
            drawPixel(x, y, color) {
                const pixelX = x * this.pixelSize;
                const pixelY = y * this.pixelSize;
                
                this.ctx.fillStyle = color;
                this.ctx.fillRect(pixelX, pixelY, this.pixelSize, this.pixelSize);
                
                this.pixels[`${x},${y}`] = color;
                
                if (this.showGrid) {
                    this.ctx.strokeStyle = '#e0e0e0';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(pixelX, pixelY, this.pixelSize, this.pixelSize);
                }
            }
            
            erasePixel(x, y) {
                this.drawPixel(x, y, '#ffffff');
                delete this.pixels[`${x},${y}`];
            }
            
            floodFill(x, y, newColor) {
                const key = `${x},${y}`;
                const originalColor = this.pixels[key] || '#ffffff';
                
                if (originalColor === newColor) return;
                
                const stack = [{x, y}];
                const visited = new Set();
                
                while (stack.length > 0) {
                    const {x: currentX, y: currentY} = stack.pop();
                    const currentKey = `${currentX},${currentY}`;
                    
                    if (visited.has(currentKey)) continue;
                    if (currentX < 0 || currentX >= this.gridSize || currentY < 0 || currentY >= this.gridSize) continue;
                    
                    const currentPixelColor = this.pixels[currentKey] || '#ffffff';
                    if (currentPixelColor !== originalColor) continue;
                    
                    visited.add(currentKey);
                    this.drawPixel(currentX, currentY, newColor);
                    
                    stack.push({x: currentX + 1, y: currentY});
                    stack.push({x: currentX - 1, y: currentY});
                    stack.push({x: currentX, y: currentY + 1});
                    stack.push({x: currentX, y: currentY - 1});
                }
            }
            
            handleCanvasClick(e) {
                const {x, y} = this.getPixelPosition(e);
                
                switch (this.currentTool) {
                    case 'pen':
                        this.drawPixel(x, y, this.currentColor);
                        break;
                    case 'eraser':
                        this.erasePixel(x, y);
                        break;
                    case 'bucket':
                        this.floodFill(x, y, this.currentColor);
                        break;
                }
            }
            
            redraw() {
                this.clearCanvas();
                
                // Ï†ÄÏû•Îêú ÌîΩÏÖÄÎì§ÏùÑ Îã§Ïãú Í∑∏Î¶¨Í∏∞
                for (const [key, color] of Object.entries(this.pixels)) {
                    const [x, y] = key.split(',').map(Number);
                    const pixelX = x * this.pixelSize;
                    const pixelY = y * this.pixelSize;
                    
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(pixelX, pixelY, this.pixelSize, this.pixelSize);
                }
                
                this.drawGrid();
            }
            
            downloadImage() {
                // Í≤©Ïûê ÏóÜÎäî Íπ®ÎÅóÌïú Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.gridSize;
                tempCanvas.height = this.gridSize;
                
                tempCtx.fillStyle = '#ffffff';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                
                for (const [key, color] of Object.entries(this.pixels)) {
                    const [x, y] = key.split(',').map(Number);
                    tempCtx.fillStyle = color;
                    tempCtx.fillRect(x, y, 1, 1);
                }
                
                const link = document.createElement('a');
                link.download = 'pixel-art.png';
                link.href = tempCanvas.toDataURL();
                link.click();
            }
            
            bindEvents() {
                // Ï∫îÎ≤ÑÏä§ Ïù¥Î≤§Ìä∏
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                
                this.canvas.addEventListener('mousedown', (e) => {
                    this.isDrawing = true;
                    this.handleCanvasClick(e);
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isDrawing && (this.currentTool === 'pen' || this.currentTool === 'eraser')) {
                        this.handleCanvasClick(e);
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.isDrawing = false;
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    this.isDrawing = false;
                });
                
                // ÎèÑÍµ¨ Ïù¥Î≤§Ìä∏
                document.getElementById('penTool').addEventListener('click', () => this.setTool('pen'));
                document.getElementById('eraserTool').addEventListener('click', () => this.setTool('eraser'));
                document.getElementById('bucketTool').addEventListener('click', () => this.setTool('bucket'));
                
                // ÏÉâÏÉÅ Ïù¥Î≤§Ìä∏
                document.getElementById('colorPicker').addEventListener('change', (e) => {
                    this.currentColor = e.target.value;
                });
                
                // ÌîÑÎ¶¨ÏÖã ÏÉâÏÉÅ Ïù¥Î≤§Ìä∏
                document.querySelectorAll('.preset-color').forEach(colorDiv => {
                    colorDiv.addEventListener('click', () => {
                        this.currentColor = colorDiv.dataset.color;
                        document.getElementById('colorPicker').value = this.currentColor;
                    });
                });
                
                // Ï∫îÎ≤ÑÏä§ ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω
                document.getElementById('canvasSize').addEventListener('change', (e) => {
                    this.gridSize = parseInt(e.target.value);
                    this.initCanvas();
                });
                
                // ÌîΩÏÖÄ ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω
                document.getElementById('pixelSize').addEventListener('change', (e) => {
                    this.pixelSize = parseInt(e.target.value);
                    this.initCanvas();
                    this.redraw();
                });
                
                // Ïª®Ìä∏Î°§ Î≤ÑÌäºÎì§
                document.getElementById('clearCanvas').addEventListener('click', (e) => {
                    console.log('Ï†ÑÏ≤¥ÏßÄÏö∞Í∏∞ Î≤ÑÌäº ÌÅ¥Î¶≠Îê®!'); // ÎîîÎ≤ÑÍπÖÏö©
                    
                    // ÏùºÎã® confirm ÏóÜÏù¥ Î∞îÎ°ú ÏßÄÏõåÎ≥¥Í∏∞ (ÌÖåÏä§Ìä∏Ïö©)
                    console.log('Ï∫îÎ≤ÑÏä§ ÏßÄÏö∞Í∏∞ Ïã§Ìñâ Ï§ë...'); 
                    this.clearCanvas();
                    
                    // Ïã§Ï†ú ÏÇ¨Ïö©ÏãúÏóêÎäî ÏïÑÎûò ÏΩîÎìú ÏÇ¨Ïö©:
                    /*
                    const userConfirmed = confirm('Ï†ïÎßê Î™®Îì† ÎÇ¥Ïö©ÏùÑ ÏßÄÏö∞ÏãúÍ≤†ÏäµÎãàÍπå?');
                    if (userConfirmed) {
                        this.clearCanvas();
                    }
                    */
                });
                
                document.getElementById('downloadImage').addEventListener('click', () => this.downloadImage());
                
                document.getElementById('gridToggle').addEventListener('click', () => {
                    this.showGrid = !this.showGrid;
                    this.redraw();
                });
                
                // NFT Í¥ÄÎ†® Ïù¥Î≤§Ìä∏
                document.getElementById('connectWallet').addEventListener('click', (e) => {
                    console.log('ÏßÄÍ∞ëÏó∞Í≤∞ Î≤ÑÌäº ÌÅ¥Î¶≠Îê®!'); // ÎîîÎ≤ÑÍπÖÏö©
                    e.preventDefault();
                    this.connectWallet();
                });
                document.getElementById('mintNFT').addEventListener('click', () => this.openMintModal());
                document.getElementById('cancelMint').addEventListener('click', () => this.closeMintModal());
                document.getElementById('nftForm').addEventListener('submit', (e) => this.handleMintSubmit(e));
                document.querySelector('.close').addEventListener('click', () => this.closeMintModal());
                
                // Î™®Îã¨ Ïô∏Î∂Ä ÌÅ¥Î¶≠ Ïãú Îã´Í∏∞
                document.getElementById('nftModal').addEventListener('click', (e) => {
                    if (e.target === document.getElementById('nftModal')) {
                        this.closeMintModal();
                    }
                });
            }
            
            setTool(tool) {
                this.currentTool = tool;
                
                // Î≤ÑÌäº ÌôúÏÑ±Ìôî ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                document.querySelectorAll('.tools button').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tool + 'Tool').classList.add('active');
                
                // Ïª§ÏÑú Î™®Ïñë Î≥ÄÍ≤Ω
                if (tool === 'bucket') {
                    this.canvas.style.cursor = 'pointer';
                } else {
                    this.canvas.style.cursor = 'crosshair';
                }
            }
            
            // Web3 Î∞è NFT Í¥ÄÎ†® Î©îÏÜåÎìúÎì§
            async initWeb3() {
                if (typeof window.ethereum !== 'undefined') {
                    console.log('MetaMaskÍ∞Ä Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§!');
                } else {
                    console.log('MetaMaskÎ•º ÏÑ§ÏπòÌï¥Ï£ºÏÑ∏Ïöî!');
                }
            }
            
            async connectWallet() {
                console.log('connectWallet Ìï®Ïàò Ïã§ÌñâÎê®!'); // ÎîîÎ≤ÑÍπÖÏö©
                
                try {
                    // MetaMask ÏÑ§Ïπò ÌôïÏù∏
                    if (typeof window.ethereum === 'undefined') {
                        console.log('MetaMaskÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏùå');
                        alert('MetaMaskÎ•º ÏÑ§ÏπòÌï¥Ï£ºÏÑ∏Ïöî!\n\n1. https://metamask.io Î∞©Î¨∏\n2. MetaMask ÏÑ§Ïπò\n3. ÏÉà ÏßÄÍ∞ë ÏÉùÏÑ± ÎòêÎäî Î≥µÏõê');
                        window.open('https://metamask.io/download/', '_blank');
                        return;
                    }
                    
                    console.log('MetaMask Í∞êÏßÄÎê®, Ïó∞Í≤∞ ÏãúÎèÑ Ï§ë...');
                    
                    // Í≥ÑÏ†ï ÏöîÏ≤≠
                    const accounts = await window.ethereum.request({
                        method: 'eth_requestAccounts'
                    });
                    
                    console.log('Ïó∞Í≤∞Îêú Í≥ÑÏ†ï:', accounts);
                    
                    if (accounts.length === 0) {
                        alert('MetaMaskÏóêÏÑú Í≥ÑÏ†ïÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.');
                        return;
                    }
                    
                    this.account = accounts[0];
                    console.log('ÏÑ†ÌÉùÎêú Í≥ÑÏ†ï:', this.account);
                    
                    // UI ÏóÖÎç∞Ïù¥Ìä∏
                    const walletStatus = document.getElementById('walletStatus');
                    const connectButton = document.getElementById('connectWallet');
                    const mintButton = document.getElementById('mintNFT');
                    
                    walletStatus.textContent = `Ïó∞Í≤∞Îê®: ${this.account.slice(0, 6)}...${this.account.slice(-4)}`;
                    walletStatus.classList.add('connected');
                    connectButton.textContent = 'ÏßÄÍ∞ë Ïó∞Í≤∞Îê®';
                    connectButton.disabled = true;
                    mintButton.disabled = false;
                    
                    console.log('UI ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å');
                    
                    // Web3 Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
                    if (typeof Web3 !== 'undefined') {
                        this.web3 = new Web3(window.ethereum);
                        console.log('Web3 Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±Îê®');
                    } else {
                        console.log('Web3 ÎùºÏù¥Î∏åÎü¨Î¶¨Í∞Ä Î°úÎìúÎêòÏßÄ ÏïäÏùå');
                    }
                    
                    // ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†ïÎ≥¥ ÌôïÏù∏
                    const chainId = await window.ethereum.request({
                        method: 'eth_chainId'
                    });
                    console.log('ÌòÑÏû¨ ÎÑ§Ìä∏ÏõåÌÅ¨ Ï≤¥Ïù∏ ID:', chainId);
                    
                    // ÏÑ±Í≥µ Î©îÏãúÏßÄ
                    alert('üéâ ÏßÄÍ∞ë Ïó∞Í≤∞ ÏÑ±Í≥µ!\n\nÏó∞Í≤∞Îêú Ï£ºÏÜå: ' + this.account);
                    
                } catch (error) {
                    console.error('ÏßÄÍ∞ë Ïó∞Í≤∞ Ïã§Ìå®:', error);
                    
                    if (error.code === 4001) {
                        alert('ÏÇ¨Ïö©ÏûêÍ∞Ä Ïó∞Í≤∞ÏùÑ Í±∞Î∂ÄÌñàÏäµÎãàÎã§.');
                    } else {
                        alert('ÏßÄÍ∞ë Ïó∞Í≤∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error.message);
                    }
                }
            }
            
            async switchToMumbai() {
                try {
                    const chainId = await window.ethereum.request({
                        method: 'eth_chainId'
                    });
                    
                    if (chainId !== '0x13881') {
                        try {
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: '0x13881' }],
                            });
                        } catch (switchError) {
                            if (switchError.code === 4902) {
                                await this.addMumbaiNetwork();
                            } else {
                                throw switchError;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Mumbai ÎÑ§Ìä∏ÏõåÌÅ¨ Ï†ÑÌôò Ïã§Ìå®:', error);
                    alert('Mumbai ÌÖåÏä§Ìä∏ÎÑ∑ Ï†ÑÌôòÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
                }
            }
            
            showTestTokenInfo() {
                const message = `üéâ Mumbai ÌÖåÏä§Ìä∏ÎÑ∑ Ïó∞Í≤∞ ÏôÑÎ£å!\n\nüí∞ ÌÖåÏä§Ìä∏ MATICÏù¥ ÌïÑÏöîÌïòÎ©¥:\n1. https://faucet.polygon.technology/ Î∞©Î¨∏\n2. ÏßÄÍ∞ë Ï£ºÏÜå ÏûÖÎ†•: ${this.account}\n3. Î¨¥Î£å ÌÖåÏä§Ìä∏ MATIC Î∞õÍ∏∞\n\nüìù NFT ÎØºÌåÖ Ï§ÄÎπÑ ÏôÑÎ£å!`;
                
                if (confirm(message + '\n\nÌÖåÏä§Ìä∏ MATIC Î∞õÏúºÎü¨ Í∞àÍπåÏöî?')) {
                    window.open('https://faucet.polygon.technology/', '_blank');
                }
            }
            
            async addMumbaiNetwork() {
                try {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0x13881',
                            chainName: 'Polygon Mumbai Testnet',
                            nativeCurrency: {
                                name: 'MATIC',
                                symbol: 'MATIC',
                                decimals: 18,
                            },
                            rpcUrls: ['https://rpc-mumbai.maticvigil.com/'],
                            blockExplorerUrls: ['https://mumbai.polygonscan.com/'],
                        }],
                    });
                } catch (addError) {
                    console.error('ÎÑ§Ìä∏ÏõåÌÅ¨ Ï∂îÍ∞Ä Ïã§Ìå®:', addError);
                    throw addError;
                }
            }
            
            openMintModal() {
                if (Object.keys(this.pixels).length === 0) {
                    alert('Î®ºÏ†Ä ÌîΩÏÖÄÏïÑÌä∏Î•º Í∑∏Î†§Ï£ºÏÑ∏Ïöî!');
                    return;
                }
                document.getElementById('nftModal').style.display = 'block';
            }
            
            closeMintModal() {
                document.getElementById('nftModal').style.display = 'none';
                document.getElementById('nftForm').reset();
            }
            
            async handleMintSubmit(e) {
                e.preventDefault();
                
                const name = document.getElementById('nftName').value;
                const description = document.getElementById('nftDescription').value;
                const attributes = document.getElementById('nftAttributes').value;
                
                try {
                    await this.mintNFT(name, description, attributes);
                } catch (error) {
                    console.error('NFT ÎØºÌåÖ Ïã§Ìå®:', error);
                    alert('NFT ÎØºÌåÖÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ' + error.message);
                }
            }
            
            async mintNFT(name, description, attributes) {
                if (!this.account) {
                    alert('Î®ºÏ†Ä ÏßÄÍ∞ëÏùÑ Ïó∞Í≤∞Ìï¥Ï£ºÏÑ∏Ïöî!');
                    return;
                }
                
                try {
                    // Î°úÎî© ÌëúÏãú
                    document.getElementById('confirmMint').disabled = true;
                    document.getElementById('confirmMint').textContent = 'ÎØºÌåÖ Ï§ë...';
                    
                    // ÌîΩÏÖÄÏïÑÌä∏Î•º Base64Î°ú Î≥ÄÌôò
                    const imageData = this.getImageAsBase64();
                    
                    // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                    const metadata = {
                        name: name,
                        description: description,
                        image: imageData,
                        attributes: this.parseAttributes(attributes),
                        created_by: this.account,
                        created_at: new Date().toISOString(),
                        canvas_size: `${this.gridSize}x${this.gridSize}`,
                        pixel_count: Object.keys(this.pixels).length,
                        network: 'Polygon Mumbai Testnet'
                    };
                    
                    console.log('NFT Î©îÌÉÄÎç∞Ïù¥ÌÑ∞:', metadata);
                    
                    // Î©îÌÉÄÎç∞Ïù¥ÌÑ∞Î•º JSON ÌååÏùºÎ°ú Îã§Ïö¥Î°úÎìú
                    const dataStr = JSON.stringify(metadata, null, 2);
                    const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                    
                    const exportFileDefaultName = `${name.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_nft_metadata.json`;
                    
                    const linkElement = document.createElement('a');
                    linkElement.setAttribute('href', dataUri);
                    linkElement.setAttribute('download', exportFileDefaultName);
                    linkElement.click();
                    
                    alert(`üé® NFT Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ ÏÉùÏÑ± ÏôÑÎ£å!\n\nÏûëÌíàÎ™Ö: ${name}\nÏÑ§Î™Ö: ${description}\n\n${exportFileDefaultName} ÌååÏùºÏù¥ Îã§Ïö¥Î°úÎìúÎêòÏóàÏäµÎãàÎã§.\n\nÏã§Ï†ú ÎØºÌåÖÏùÑ ÏúÑÌï¥ÏÑúÎäî ThirdwebÏóêÏÑú Ïä§ÎßàÌä∏ Ïª®Ìä∏ÎûôÌä∏Î•º Î∞∞Ìè¨Ìï¥Ï£ºÏÑ∏Ïöî!`);
                    
                    this.closeMintModal();
                    
                } catch (error) {
                    console.error('NFT Ï≤òÎ¶¨ Ïã§Ìå®:', error);
                    alert(`Ï≤òÎ¶¨ Ïã§Ìå®: ${error.message}`);
                } finally {
                    document.getElementById('confirmMint').disabled = false;
                    document.getElementById('confirmMint').textContent = 'ÎØºÌåÖÌïòÍ∏∞';
                }
            }
            
            getImageAsBase64() {
                // Í≤©Ïûê ÏóÜÎäî Íπ®ÎÅóÌïú Ïù¥ÎØ∏ÏßÄ ÏÉùÏÑ±
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.gridSize;
                tempCanvas.height = this.gridSize;
                
                tempCtx.fillStyle = '#ffffff';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                
                for (const [key, color] of Object.entries(this.pixels)) {
                    const [x, y] = key.split(',').map(Number);
                    tempCtx.fillStyle = color;
                    tempCtx.fillRect(x, y, 1, 1);
                }
                
                return tempCanvas.toDataURL('image/png');
            }
            
            parseAttributes(attributesString) {
                if (!attributesString) return [];
                
                return attributesString.split(',').map(attr => {
                    const [key, value] = attr.split(':').map(s => s.trim());
                    return { trait_type: key, value: value };
                }).filter(attr => attr.trait_type && attr.value);
            }
        }
        
        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú ÏóêÎîîÌÑ∞ Ï¥àÍ∏∞Ìôî
        window.addEventListener('load', () => {
            new PixelArtEditor();
        });
    </script>
</body>
</html>
                